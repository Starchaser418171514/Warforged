#include "charactermoveset.h"
#include "base.h"

using namespace std;

Character::Character(Coordinate pos, int att, int ultReq) : 
    position(pos), attackStat(att), ultimateTurnRequirement(ultReq),
    points(0), turnsSinceLastUltimate(0), ultimateReady(false),
    shieldActive(false), shieldDuration(0), shieldReduction(0.0f) {}

Character::~Character() {}

void Character::beginTurn() {
    points = min(points + 1, MAX_POINTS);
    turnsSinceLastUltimate++;
    if (turnsSinceLastUltimate >= ultimateTurnRequirement) {
        ultimateReady = true;
    }
}

bool Character::basicAttack(Coordinate target, vector<vector<string>>& grid) {
    if (!isValid(target)) return false;

    int damage = attackStat;
    cout << characterType << " basic attack on (" << target.x << ", " << target.y 
         << ") for " << damage << " damage!\n";
    return true;
}

void Character::applyDamageReductionShield(int duration, float reduction) {
    shieldActive = true;
    shieldDuration = duration;
    shieldReduction = reduction;
}

int Character::applyDamageReduction(int incomingDamage) {
    return shieldActive ? static_cast<int>(incomingDamage * (1.0f - shieldReduction)) : incomingDamage;
}

void Character::endTurn() {
    if (shieldActive && --shieldDuration <= 0) {
        shieldActive = false;
        cout << characterType << "'s shield expired.\n";
    }
}

Coordinate Character::getPosition() const { return position; }
string Character::getType() const { return characterType; }
bool Character::isUltimateReady() const { return ultimateReady; }
bool Character::hasShield() const { return shieldActive; }

Tank::Tank(Coordinate pos, int att) : Character(pos, att, 5),
    counterActive(false), counterRange(2) {
    characterType = "Tank";
}

bool Tank::useSkill(vector<vector<string>>& grid) {
    if (points < 2) return false;
    counterActive = true;
    points -= 2;
    cout << "Tank: Counter stance activated!\n";
    return true;
}

bool Tank::useUltimateOn(Character& target, vector<vector<string>>& grid) {
    if (!ultimateReady) return false;
    target.applyDamageReductionShield(3, 0.5f);
    ultimateReady = false;
    turnsSinceLastUltimate = 0;
    cout << "Tank shielded " << target.getType() << " (50% reduction for 3 turns)!\n";
    return true;
}

bool Tank::useUltimate(Coordinate target, vector<vector<string>>& grid) {
    return useUltimateOn(*this, grid);
}

void Tank::allyGotHit(Coordinate allyPos, Coordinate enemyPos, vector<vector<string>>& grid) {
    if (counterActive && (abs(allyPos.x - position.x) + abs(allyPos.y - position.y)) <= counterRange) {
        cout << "Tank counters (" << enemyPos.x << "," << enemyPos.y << ")!\n";
        basicAttack(enemyPos, grid);
    }
}

Fighter::Fighter(Coordinate pos, int att) : Character(pos, att, 4),
    attackBuffTurns(0), attackBuffMultiplier(1.5f) {
    characterType = "Fighter";
}

bool Fighter::useSkill(vector<vector<string>>& grid) {
    if (points < 2) return false;
    attackBuffTurns = 3;
    points -= 2;
    cout << "Fighter: Attack Boost active for 3 turns!\n";
    return true;
}

bool Fighter::useUltimate(Coordinate target, vector<vector<string>>& grid) {
    if (!ultimateReady) return false;
    ultimateReady = false;
    turnsSinceLastUltimate = 0;
    cout << "Fighter uses Fatal Blow!\n";
    return true;
}

int Fighter::getAttackStat() const {
    return attackBuffTurns > 0 ? static_cast<int>(attackStat * attackBuffMultiplier) : attackStat;
}

void Fighter::endTurn() {
    Character::endTurn();
    if (attackBuffTurns > 0) attackBuffTurns--;
}

Marksman::Marksman(Coordinate pos, int att) : Character(pos, att, 6),
    aoeRange(2), ultimateRange(5) {
    characterType = "Marksman";
}

bool Marksman::basicAttack(Coordinate target, vector<vector<string>>& grid) {
    if (!isValid(target)) return false;

    int distance = abs(target.x - position.x) + abs(target.y - position.y);
    if (distance > 3) {
        cout << "Target out of range (max 3 tiles)!\n";
        return false;
    }

    cout << "Marksman shoots (" << target.x << "," << target.y << ") for "
         << attackStat << " damage!\n";
    return true;
}

bool Marksman::useSkill(Coordinate center, vector<vector<string>>& grid) {
    if (points < 2 || !isValid(center)) return false;

    int distance = abs(center.x - position.x) + abs(center.y - position.y);
    if (distance > 2) {
        cout << "AOE center out of range (max 2 tiles)!\n";
        return false;
    }

    points -= 2;
    cout << "Marksman AOE centered at (" << center.x << "," << center.y << "):\n";

    bool hitAny = false;
    for (int dx = -aoeRange; dx <= aoeRange; dx++) {
        for (int dy = -aoeRange; dy <= aoeRange; dy++) {
            if (dx == 0 && dy == 0) continue;

            Coordinate target = {center.x + dx, center.y + dy};
            if (isValid(target) && isMonster(target, grid)) {
                cout << "  Hit (" << target.x << "," << target.y << ")\n";
                hitAny = true;
            }
        }
    }
    return hitAny;
}

bool Marksman::useUltimate(Coordinate target, vector<vector<string>>& grid) {
    if (!ultimateReady || !isValid(target)) return false;

    int distance = abs(target.x - position.x) + abs(target.y - position.y);
    if (distance > ultimateRange) {
        cout << "Target out of ultimate range (max 5 tiles)!\n";
        return false;
    }

    ultimateReady = false;
    turnsSinceLastUltimate = 0;
    cout << "Marksman KNOCKBACK SHOT on (" << target.x << "," << target.y << ")!\n";
    return true;
}
